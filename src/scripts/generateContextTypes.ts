import { writeFileSync } from "fs";
import chalk from "chalk";
import { join } from "path";
import { pascal } from "case";
import isEmpty from "lodash/isEmpty";
import { ISerializedGast } from "chevrotain";

type Node =
  | FlatNode
  | RuleNode
  | AlternationNode
  | NonTerminalNode
  | TerminalNode
  | RepetitionWithSeparatorNode
  | OptionNode
  | RepetitionNode
  | RepetitionMandatoryWithSeparator
  | { type: "RepetitionMandatory" };

interface RuleNode {
  type: "Rule";
  name: string;
  orgText: string;
  definition: Node[];
}

interface FlatNode {
  type: "Flat";
  definition: Node[];
}

interface AlternationNode {
  type: "Alternation";
  idx: number;
  definition: FlatNode[];
}

interface NonTerminalNode {
  type: "NonTerminal";
  name: string;
  idx: number;
}

interface TerminalNode {
  type: "Terminal";
  name: string;
  label: string;
  idx: number;
  pattern: string;
}

interface RepetitionWithSeparatorNode {
  type: "RepetitionWithSeparator";
  idx: number;
  separator: TerminalNode;
  definition: Node[];
}

interface RepetitionMandatoryWithSeparator {
  type: "RepetitionMandatoryWithSeparator";
  idx: number;
  separator: TerminalNode;
  definition: NonTerminalNode[];
}

interface OptionNode {
  type: "Option";
  idx: number;
  definition: Node[];
}

interface RepetitionNode {
  type: "Repetition";
  idx: number;
  definition: Node[];
}

/**
 * Script to generate context types from the grammar.
 *
 * Result:
 *  `src/Context.ts`
 */
export function generateContextTypes(grammar: ISerializedGast[]) {
  let types = `// Auto-generated by generateContextTypes.ts
import { IToken } from "chevrotain";
`;
  const IContext: string[] = [];

  // Improve the type safety with our own types, `RuleNode[]` is a better version of `ISerializedGast[]`
  (grammar as RuleNode[]).forEach(rule => {
    const def = generateDefinitionTypes(rule.definition, 2);
    IContext.push(`${pascal(rule.name)}Context`);
    types += def.includes("|")
      ? `\nexport type ${pascal(rule.name)}Context = \n  | {\n`
      : `\nexport interface ${pascal(rule.name)}Context {`;
    types += def;
    types += "\n}\n\n";
  });
  types += `export type IContext = ${IContext.join(" | ")}\n`;
  writeFileSync(join(__dirname, "../Context.ts"), types);
  console.log(chalk.green("âœ”") + " context types generated!");
}

function generateDefinitionTypes(
  definition: Node[],
  indent = 2,
  optionnal = false,
  keys: string[] = [] // store of previous keys to prevent duplicate
): string {
  return definition
    .map(node => {
      switch (node.type) {
        case "Terminal":
          if (keys.includes(node.name)) return "";
          keys.push(node.name);
          return `\n${" ".repeat(indent)}${node.name}${
            optionnal ? "?" : ""
          }: IToken[];`;

        case "NonTerminal":
          if (keys.includes(node.name)) return "";
          keys.push(node.name);
          return `\n${" ".repeat(indent)}${node.name}: Array<{\n${" ".repeat(
            indent + 2
          )}name: "${node.name}";\n${" ".repeat(indent + 2)}children: ${pascal(
            node.name
          )}Context;\n${" ".repeat(indent)}}>;`;

        case "Option":
          return generateDefinitionTypes(node.definition, indent, true, keys);

        case "RepetitionMandatoryWithSeparator":
          return generateDefinitionTypes(
            [...node.definition, node.separator],
            indent + 2,
            true,
            keys
          );

        case "Repetition":
          return generateDefinitionTypes(
            node.definition,
            indent + 2,
            true,
            keys
          );

        case "Alternation":
          const isTerminalOnly = !JSON.stringify(node.definition).includes(
            "NonTerminal"
          );

          const entries = new Set();
          return "\n" + isTerminalOnly
            ? node.definition
                .map(i => generateDefinitionTypes(i.definition, 0, true))
                .join("")
                .split("\n")
                .filter((j: string) => {
                  const isAlreadyDefined = entries.has(j);
                  if (!j.includes("}>;")) {
                    entries.add(j);
                  }
                  return !isEmpty(j) && !isAlreadyDefined;
                })
                .join("\n")
            : node.definition
                .map(i =>
                  generateDefinitionTypes(i.definition, 0).replace("\n", "")
                )
                .join("} | {");

        case "Flat":
          return generateDefinitionTypes(node.definition).replace(/[\n;]/g, "");

        default:
          return "";
      }
    })
    .join("");
}
