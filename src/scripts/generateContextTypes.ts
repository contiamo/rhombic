import { writeFileSync } from "fs";
import chalk from "chalk";
import { join } from "path";
import { pascal } from "case";
import isEmpty from "lodash/isEmpty";
import { ISerializedGast } from "chevrotain";

export type Node =
  | FlatNode
  | RuleNode
  | AlternationNode
  | NonTerminalNode
  | TerminalNode
  | RepetitionWithSeparatorNode
  | OptionNode
  | RepetitionNode
  | RepetitionMandatoryWithSeparator
  | { type: "RepetitionMandatory" };

interface RuleNode {
  type: "Rule";
  name: string;
  orgText: string;
  definition: Node[];
}

interface FlatNode {
  type: "Flat";
  definition: Node[];
}

interface AlternationNode {
  type: "Alternation";
  idx: number;
  definition: FlatNode[];
}

interface NonTerminalNode {
  type: "NonTerminal";
  name: string;
  idx: number;
}

interface TerminalNode {
  type: "Terminal";
  name: string;
  label: string;
  idx: number;
  pattern: string;
}

interface RepetitionWithSeparatorNode {
  type: "RepetitionWithSeparator";
  idx: number;
  separator: TerminalNode;
  definition: Node[];
}

interface RepetitionMandatoryWithSeparator {
  type: "RepetitionMandatoryWithSeparator";
  idx: number;
  separator: TerminalNode;
  definition: NonTerminalNode[];
}

interface OptionNode {
  type: "Option";
  idx: number;
  definition: Node[];
}

interface RepetitionNode {
  type: "Repetition";
  idx: number;
  definition: Node[];
}

const alternationLink = `}) & {`;

/**
 * Script to generate context types from the grammar.
 *
 * Result:
 *  `src/Context.ts`
 */
export function generateContextTypes(grammar: ISerializedGast[]) {
  let types = `// Auto-generated by generateContextTypes.ts
import { IToken } from "chevrotain";
`;
  const IContext: string[] = [];

  // Improve the type safety with our own types, `RuleNode[]` is a better version of `ISerializedGast[]`
  (grammar as RuleNode[]).forEach(rule => {
    const def = generateDefinitionTypes(rule.definition);
    IContext.push(`${pascal(rule.name)}Context`);
    types += def.includes("|")
      ? `\nexport type ${pascal(rule.name)}Context = \n  ${def.includes(alternationLink) ? "(" : ""} | {\n`
      : `\nexport interface ${pascal(rule.name)}Context {`;
    types += def;
    types += "\n}\n\n";
  });
  types += `export type IContext = ${IContext.join(" | ")}\n`;
  writeFileSync(join(__dirname, "../Context.ts"), types);
  console.log(chalk.green("âœ”") + " context types generated!");
}

export function generateDefinitionTypes(
  definition: Node[],
  options?: {
    indent?: number;
    optional?: boolean;
    keys?: string[]; // store of previous keys to prevent duplicate
  }
): string {
  const { indent, optional, keys } = {
    keys: [] as string[],
    indent: 2,
    optional: false,
    ...options
  };

  return definition.reduce(
    ({ output, isAfterAlternation }, node) => {
      // Avoid the next node to be inside the Alternation union
      if (isAfterAlternation && output.includes("} | {")) {
        output += alternationLink;
      }

      switch (node.type) {
        case "Terminal":
          if (keys.includes(node.name)) {
            if (!optional) {
              // Remove optional from definition
              return {
                output: output.replace(`${node.name}?: IToken[];`, `${node.name}: IToken[];`),
                isAfterAlternation: false
              };
            }
            return { output, isAfterAlternation: false };
          }
          keys.push(node.name);
          return {
            output: `${output}\n${" ".repeat(indent)}${node.name}${optional ? "?" : ""}: IToken[];`,
            isAfterAlternation: false
          };

        case "NonTerminal":
          if (keys.includes(node.name)) return { output, isAfterAlternation: false };
          keys.push(node.name);
          return {
            output: `${output}\n${" ".repeat(indent)}${node.name}${optional ? "?" : ""}: Array<{\n${" ".repeat(
              indent + 2
            )}name: "${node.name}";\n${" ".repeat(indent + 2)}children: ${pascal(node.name)}Context;\n${" ".repeat(
              indent
            )}}>;`,
            isAfterAlternation: false
          };

        case "Option":
          return {
            output:
              output +
              generateDefinitionTypes(node.definition, {
                indent,
                optional: true,
                keys
              }),
            isAfterAlternation: false
          };

        case "RepetitionMandatoryWithSeparator":
          return {
            output:
              output +
              generateDefinitionTypes(node.definition, {
                indent: indent + 2,
                keys
              }) +
              generateDefinitionTypes([node.separator], {
                indent: indent + 2,
                optional: true,
                keys
              }),
            isAfterAlternation: false
          };

        case "Repetition":
          return {
            output:
              output +
              generateDefinitionTypes(node.definition, {
                indent: indent + 2,
                optional: true,
                keys
              }),
            isAfterAlternation: false
          };

        case "Alternation": {
          const isTerminalOnly = !JSON.stringify(node.definition).includes("NonTerminal");

          const entries = new Set();
          return {
            output:
              output +
              "\n" +
              (isTerminalOnly
                ? node.definition
                    .map(i =>
                      generateDefinitionTypes(i.definition, {
                        indent: 0,
                        optional: true,
                        keys
                      })
                    )
                    .join("")
                    .split("\n")
                    .filter((j: string) => {
                      const isAlreadyDefined = entries.has(j);
                      if (!j.includes("}>;")) {
                        entries.add(j);
                      }
                      return !isEmpty(j) && !isAlreadyDefined;
                    })
                    .join("\n")
                : node.definition
                    .map(i =>
                      generateDefinitionTypes(i.definition, {
                        indent: 0
                      }).replace("\n", "")
                    )
                    .join("} | {")),
            isAfterAlternation: true
          };
        }

        case "Flat":
          return {
            output: output + generateDefinitionTypes(node.definition).replace(/[\n;]/g, ""),
            isAfterAlternation: false
          };

        default:
          return { output, isAfterAlternation: false };
      }
    },
    { output: "", isAfterAlternation: false }
  ).output;
}
