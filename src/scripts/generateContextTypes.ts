import { writeFileSync } from "fs";
import chalk from "chalk";
import { join } from "path";
import { pascal } from "case";
import isEmpty from "lodash/isEmpty";
import { ISerializedGast } from "chevrotain";

export type Node =
  | FlatNode
  | RuleNode
  | AlternationNode
  | NonTerminalNode
  | TerminalNode
  | RepetitionWithSeparatorNode
  | OptionNode
  | RepetitionNode
  | RepetitionMandatoryWithSeparator
  | { type: "RepetitionMandatory" };

interface RuleNode {
  type: "Rule";
  name: string;
  orgText: string;
  definition: Node[];
}

interface FlatNode {
  type: "Flat";
  definition: Node[];
}

interface AlternationNode {
  type: "Alternation";
  idx: number;
  definition: FlatNode[];
}

interface NonTerminalNode {
  type: "NonTerminal";
  name: string;
  idx: number;
}

interface TerminalNode {
  type: "Terminal";
  name: string;
  label: string;
  idx: number;
  pattern: string;
}

interface RepetitionWithSeparatorNode {
  type: "RepetitionWithSeparator";
  idx: number;
  separator: TerminalNode;
  definition: Node[];
}

interface RepetitionMandatoryWithSeparator {
  type: "RepetitionMandatoryWithSeparator";
  idx: number;
  separator: TerminalNode;
  definition: NonTerminalNode[];
}

interface OptionNode {
  type: "Option";
  idx: number;
  definition: Node[];
}

interface RepetitionNode {
  type: "Repetition";
  idx: number;
  definition: Node[];
}

/**
 * Script to generate context types from the grammar.
 *
 * Result:
 *  `src/Context.ts`
 */
export function generateContextTypes(grammar: ISerializedGast[]) {
  let types = `// Auto-generated by generateContextTypes.ts
import { IToken } from "chevrotain";
`;
  const IContext: string[] = [];

  // Improve the type safety with our own types, `RuleNode[]` is a better version of `ISerializedGast[]`
  (grammar as RuleNode[]).forEach(rule => {
    const def = generateDefinitionTypes(rule.definition, 2);
    IContext.push(`${pascal(rule.name)}Context`);
    types += def.includes("|")
      ? `\nexport type ${pascal(rule.name)}Context = \n  | {\n`
      : `\nexport interface ${pascal(rule.name)}Context {`;
    types += def;
    types += "\n}\n\n";
  });
  types += `export type IContext = ${IContext.join(" | ")}\n`;
  writeFileSync(join(__dirname, "../Context.ts"), types);
  console.log(chalk.green("âœ”") + " context types generated!");
}

export function generateDefinitionTypes(
  definition: Node[],
  indent = 2,
  optionnal = false,
  keys: string[] = [] // store of previous keys to prevent duplicate
): string {
  return definition.reduce((output, node) => {
    switch (node.type) {
      case "Terminal":
        if (keys.includes(node.name)) {
          if (!optionnal) {
            // Remove optional from definition
            return output.replace(
              `${node.name}?: IToken[];`,
              `${node.name}: IToken[];`
            );
          }
          return output;
        }
        keys.push(node.name);
        return `${output}\n${" ".repeat(indent)}${node.name}${
          optionnal ? "?" : ""
        }: IToken[];`;

      case "NonTerminal":
        if (keys.includes(node.name)) return output;
        keys.push(node.name);
        return `${output}\n${" ".repeat(indent)}${node.name}${
          optionnal ? "?" : ""
        }: Array<{\n${" ".repeat(indent + 2)}name: "${
          node.name
        }";\n${" ".repeat(indent + 2)}children: ${pascal(
          node.name
        )}Context;\n${" ".repeat(indent)}}>;`;

      case "Option":
        return (
          output + generateDefinitionTypes(node.definition, indent, true, keys)
        );

      case "RepetitionMandatoryWithSeparator":
        return (
          output +
          generateDefinitionTypes(node.definition, indent + 2, false, keys) +
          generateDefinitionTypes([node.separator], indent + 2, true, keys)
        );

      case "Repetition":
        return (
          output +
          generateDefinitionTypes(node.definition, indent + 2, true, keys)
        );

      case "Alternation":
        const isTerminalOnly = !JSON.stringify(node.definition).includes(
          "NonTerminal"
        );

        const entries = new Set();
        return (
          output +
          "\n" +
          (isTerminalOnly
            ? node.definition
                .map(i => generateDefinitionTypes(i.definition, 0, true, keys))
                .join("")
                .split("\n")
                .filter((j: string) => {
                  const isAlreadyDefined = entries.has(j);
                  if (!j.includes("}>;")) {
                    entries.add(j);
                  }
                  return !isEmpty(j) && !isAlreadyDefined;
                })
                .join("\n")
            : node.definition
                .map(i =>
                  generateDefinitionTypes(i.definition, 0).replace("\n", "")
                )
                .join("} | {"))
        );

      case "Flat":
        return (
          output +
          generateDefinitionTypes(node.definition).replace(/[\n;]/g, "")
        );

      default:
        return output;
    }
  }, "");
}
